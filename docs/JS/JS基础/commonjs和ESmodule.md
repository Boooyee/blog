### CommonJS

从1999年开始，js模块化的探索都是基于语言层面的优化，真正改变要从2009年CommonJS，Node采用CommonJS模块规范，每个文件就是一个模块，有自己的作用域，在一个文件里定义的变量、函数、类都是私有的。


#### commonJS特点
1、对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。
2、对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。
3、当使用require命令加载某个模块时，就会运行整个模块的代码。同步加载模块
4、当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
5、当循环加载时，脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

#### CommonJs不足
- 缺少模块封装能力，CommonJS中每个模块都是一个文件，意味着每个模块只有一个模块。在服务器上是可行的，在浏览器中不友好
- 同步的方式加载依赖，浏览器中由于JS的加载会阻塞渲染，同步加载会导致长时间白屏，用户体验不好
- CommonJS规范中使用export暴露模块，需要导出的变量附加到export上，但是要导出一个函数确是使用module.export，这种语法让人困惑

### ES6特点

1、ES6模块中的值属于动态只读引用。
2、对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
3、对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。
4、循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。

