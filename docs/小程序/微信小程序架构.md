### 小程序

小程序基础库主要包括两部分：

- WAWebview：
  - 视图层基础库，提供视图层基础能力
- WAService
  - 逻辑层基础库，提供逻辑层基础能力

#### WAWebview 基础组成：

- Foundation：基础模块，提供环境变量 env，发布订阅 EventEmitter，配置/基础库/通信桥 Ready 事件

- WeixinJSBridge：消息通信模块，提供了视图层 JS 与 Native/视图层与逻辑层之间消息通信的机制

- exparser：组件系统模块，是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件都由 Exparser 组织管理。

- _virtualDOM_：Virtual DOM 模块，模拟了各种 DOM 接口的 wx-element 对象
- _webViewSDK_：Webview SDK 模块，视图层 API
- Reporter：日志上报模块

#### WAService 基本组成

- Foundation

- WeixinJSBridge

- WeixinNativeBuffer

- WeixinWorker：Worker 线程，小程序的逻辑线程是单线程，但是通过 Worker 可以另起独立线程，这与 html5 一致

- JSContext：JS Engine Context，数据共享对象。小程序是多 Webview 模式，每一个 Webview 都有一个独立的 JSContext，虽然可以通过窗口通信实现数据传递，但是无法共享数据和方法。

- Protect：

- _subContextEngine_：基类模块

#### 通信

视图层和逻辑层是如何进行通信的。

- ios：利用 WKWebView 提供 messageHandlers 特性

- 安卓：往 WebView 的 window 对象注入一个原生方法

最终会封装成WeiXinJSBridge这样一个兼容中间层，这个中间层主要提供了调用（invoke）和监听（on）这两种方法

#### 运行机制/清除机制

- 小程序没有重启的概念，当小程序进入后台，客户端会维持一段时间的运行状态，超过一段时间后，目前是五分钟，会被微信主动销毁。在此之间被重复打开，被视为热启动，是不检查版本更新的。

- 短时间内（5s）连续收到两次以上系统内存警告，会进行小程序销毁。


### 微信小程序架构设计

#### JSSDK

微信早期，内部一直有这样的诉求，在微信打开的h5可以调用到微信原生的一些能力。早期微信提供了Webview到原生的通信机制，在webview里注入JSbridge的接口，使得h5可以通过调用到原生能力。
```
Webview --------> Native
        <--------
```

从另一个角度看，JSBridge是微信和h5的通信协议，在2015年初的时候，微信就发布了JSSDK，就是隐藏了内部一些细节，包装了几十个API给到上层业务调用。
```
Webview --------> JSSDK  --------> Native
        <-------- JSSDK  <--------
```

开发者可以用JSSDK来调用微信的能力，来完成一些以前h5做不到或者难以做到的事情。

#### JSSDK存在的问题

第一点是加载h5出现的白屏。在微信里打开链接后会看到白屏，有一些h5服务不稳定，这个白屏现象会更严重。

第二点是h5跳转到其他页面时，切换的效果很不流畅，只能看到顶部进度条在走。

随着JSSDK的开放，还出现了更不好对付的问题。有人做假红包，有人诱导分享，有人伪造一些官方活动。他们利用JSSDK的分享能力变相的去裂变分享到各个群或者朋友圈，由于JSSDK是根据域名来赋予api权限的，运营人员封了一个域名后，他们立马用别的域名又继续做坏，要知道注册一个新的域名的成本是很低的。



#### 移动开发新模式

根据上面背景，总结下目前移动应用开发的一些特点：
* web开发门槛比较低，而App开发门槛偏高而且需要考虑IOS和安卓多个平台
* h5会有白屏和页面切换不流畅的问题，原生App体验就很好
* h5最大的优点是随时可以上线更新，但是App就比较慢，需要审核上架，还需要用户主动安装更新

新的开发模式要满足一下背景，
* 像h5一样开发门槛低
* 体验要好，要尽可能接近原生App体验
* 开发者可以云端更新，微信平台可以管控

很多人会第一时间想到Facebook的React Native（RN），是不是RN就能解决问题了呢。

RN能解决部分问题，还存在一些问题：
* RN只支持CSS的子集，作为一个开放的生态，我们还要告诉千千万万的开发者，哪些css属性能用，哪些不能用
* RN存在一些问题，这些依赖RN的修复，同时这样就变成太过依赖客户端发版本去解决开发者那边的bug，这样修复周期太长
* RN存在Lisence问题，存在隐患

所以放弃了这样的方案，改用Hybrid的方式。简单说，就是把h5所有代码打包，一次性的Load到本地再打开。这样做的好处是我们可以用一种近似web的方式来开发，同时在体验上也可以做到不错的效果，并且可以做到云端更新。
```
Web + 离线包     体验接近原生 ===== 离线包 + 页面预渲染 + 切换动可云端更新
```
现在存在最后一个问题，平台管控的问题。需要禁掉很多危险的html标签，还要禁掉一些API，要一直维护这样的白名单或者黑名单，实现成本太高了，并且未来浏览器内核一旦更新，存在很大安全隐患。

#### 安全管控

Web + 离线包的方式可以解决很多问题，但是遗留一个安全问题有待解决。经过讨论，决定把开发者的JS逻辑代码放到单独的线程去运行，因为不在Webview线程里，所以这个环境没有Webview任何接口，自然开发者就没办法直接操作DOM，也就没办法去更改页面，“管控”的问题得到解决。

#### 渲染问题

还有一个问题，开发者没法操作DOM，如果用户交互需要页面变化的话，开发者就没办法动态的变化页面了。所以想到了一个办法，不直接操作DOM也能做到页面刷新。

其实Facebook早就有方案解决这个问题，就是React，React引入了Virtual Dom的概念，业务测只需要改变数据即可引起页面变化。

至此，小程序双线程模型就定了下来：渲染层（Webview） + 逻辑层（JSCore）

其中渲染层用了Webview进行渲染，开发者的JS逻辑层运行在一个JSCore线程。

渲染层提供了带有数据绑定语法的WXML，逻辑层提供了setData等等API，开发者需要进行页面变化时，只需要通过setData把变化的数据传进去，小程序框架就会进行Dom Diff等流程最后把正确的结果更新在Dom树上。

在开发者的逻辑下层，还需要有一层小程序框架的支持（数据通信，API，VD算法等等），我们把它称为基础库。

我们在两个线程各自注入一份基础库，渲染层的基础库含有VD的处理以及底层组件系统的机制，对上层提供一些内置组件，例如video/image等。逻辑层的基础库主要会提供给上层一些API，例如wx.login wx.getSystemInfo等。

#### 页面交互问题

用户在屏幕点击某个按钮，开发者的逻辑层要处理一些事情，然后通过setData引起页面变化，整个过程需要四次通信。对于一些强交互（例如拖动视频进度条）的场景，这样的操作会导致用户的操作很卡。对于这种强交互场景，我们引入了原生组件，这样用户和原生组件的交互就可以节省两次通信。

原生组件和Webview不是在同一层级进行渲染，原生组件其实是叠在Webview之上。














