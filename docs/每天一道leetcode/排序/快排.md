### 快排

题目：假设给你一组无序的数字，让你找到其中排名第 k 位的数字。你会怎么做？

核心思想：找到基准值位置。

* 第一步：找到一个值作为基准值
* 第二步：找到基准值位置，把小于基准值的元素放到基准值左边，大于基准值的元素放到右边
* 第三步：基准值左右两侧递归执行这个过程

分析快排时间复杂度：

* 分析partition步骤时间复杂度：在partition操作过程中，头指针会循环扫描到基准值最后放的位置，尾指针也会扫描到最后基准值放置的位置。这样，头尾指针扫描加在一起，相当于扫描了待排序数组的区域。因此单次partition时间复杂度为O(n)。

* 整体复杂度：T(n) = n + T(L) + T(R) , 最好时间复杂度nlogn，最坏时间复杂度n*2(每次取最大或者最小).

``` 

let quickSort = function (arr) {
  if (arr.length <= 1) {
    return arr
  }
  let left = []
  let right = []
  let baseNum = arr.shift()
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < baseNum) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
  }
  return quickSort(left).concat(baseNum, quickSort(right))
}
```

#### 快速选择算法

Top K 问题：

* 快排存在的问题：

  + 首先，我们是想求排名第 k 位的元素，又不是真的想对整体序列进行排序。如果对全部数学序列进行快排，我们实际上做了大量的无用操作，这会导致算法效率很低。
  + 其次，快速排序算法的时间复杂度不稳定，很有可能退化到最坏的时间复杂度 O(n^2)。

用partition实现快速选择，基准元素的排名index与k之间的关系可能出现三种情况：

*  如果ind正好等于k，说明当前的基准值，就是我们要找的排名第k位的元素
*  如果ind大于k，说明排名第k位的元素在基准值前面。接下来就是在基准值前面查找排名第K位元素
*  如果ind小于k，说明排名第k位元素在基准值的后面，并且，当前包括基准值在内的ind个元素，都是小于基准值的元素。那么问题就转换成了，在基准值的后面查找排名第k-ind位的元素

#### 快速排序优化

* 单边递归优化
* 基准值选取优化
* partition操作优化


